<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="keywords" content="TRIKStudio, help, manual, user guide" />
<meta name="description" content="TRIKStudio help center" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Программирование ТРИК в TRIKStudio</title>
<link href="style.css" rel="stylesheet" type="text/css" media="screen" />
<script type="text/javascript" src="version.js"></script>
</head>

<body>
<div id="wrapper">
	<script type="text/javascript" src="header.html.js"></script>
	<div id="page" class="container">
		<div id="sidebar">
			<script type="text/javascript" src="contents.html.js"></script>
		</div>
		<div id="content">
			<div class="post">
				<h2 class="title">Программирование контроллера ТРИК в TRIKStudio<a href="#"></a></h2>
				<div class="entry">
					<p></p>
				</div>
			</div>

			<h3><a name="connection">Подключение робота</a></h3>

			<p>
			Подробная инструкция по настройке и подключению робота к сети находится на вики проекта, <a href="https://github.com/trikset/trikRuntime/wiki/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B5-%D0%B8-%D0%BF%D0%BE%D0%B4%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D1%8E-%D0%BA-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D1%83">Инструкция по настройке и подсоединению к контроллеру</a>. Здесь будем считать, что робот и компьютер с TRIKStudio уже находятся в одной сети. В таком случае достаточно выбрать конструктор ТРИК в окне настроек и указать IP-адрес робота (его можно посмотреть в меню "Сеть" на роботе):
			</p>

			<center><img src="pics/trik/kit-selection.png" alt="Выбор конструктора ТРИК" width="660"></center>

			<p>
			Указать IP-адрес робота можно и в окне конфигурации сенсоров прямо на главном окне TRIKStudio:
			</p>

			<center><img src="pics/trik/fast-ip-selection.png" alt="Быстрый выбор IP-адреса"></center>

			<p>
			Этих действий достаточно для работы с ТРИК в режиме генерации, для работы интерпретатора необходимо ещё установить соединение с роботом, нажав на кнопку "Подключиться" на панели инструментов:
			</p>

			<center><img src="pics/trik/connect.png" alt="Кнопка 'Подключиться'" width="660"></center>

			<h3><a name="blocks">Блоки ТРИК</a></h3>

			<p>
			Специализированные блоки для ТРИК делятся на несколько категорий:
			</p>

			<ul>
				<li><b><a href="#trik-functional-blocks">Действия</a></b> – блоки, выполняющие какое-либо действие на роботе: включение моторов, проигрывание звука и т.д.</li>
				<li><b><a href="#trik-waiting-blocks">Ожидания</a></b> – блоки, ждущие наступления какого-либо события: определённых показаний датчиков, нажатия на кнопку и т.д.</li>
				<li><b><a href="#trik-drawing-blocks">Рисования на дисплее</a></b> – блоки, используемые для вывода графики и текста на экран.</li>
			</ul>

			<h4><a name="trik-functional-blocks">Действия</a></h4>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название элемента</b></td>
					<td><b>Пиктограмма</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>Играть звук</td>
					<td><center><img src="pics/trik/playSound.png" alt="Гудок"></center></td>
					<td>Проиграть на роботе заданный звуковой файл, который должен быть заранее загружен на робот. Путь до файла указывается относительно папки trik на роботе. Загрузить файл на робот можно, например, с помощью программы <a href="http://winscp.net/eng/docs/lang:ru">WinSCP</a></td>
				</tr>
				<tr>
					<td>Моторы вперёд</td>
					<td><center><img src="pics/trik/enginesForward.png" alt="Моторы вперёд"></center></td>
					<td>Включить моторы по заданным портам с заданной мощностью. Порты задаются строками M1, M2, M3 и M4, разделенными запятыми. Мощность задается в процентах числом от -100 до 100, если задано отрицательное значение, мотор включается в режиме реверса. Так, на картинке изображена команда включения моторов на портах M3 и M4 с мощностью 100%.
					</td>
				</tr>
				<tr>
					<td>Моторы назад</td>
					<td><center><img src="pics/trik/enginesBackward.png" alt="Моторы назад"></center></td>
					<td>Включить моторы в режиме реверса по заданным портам с заданной мощностью. Параметры аналогичны параметрами блока "Моторы вперёд".</td>
				</tr>
				<tr>
					<td>Моторы стоп</td>
					<td><center><img src="pics/trik/enginesStop.png" alt="Моторы стоп"></center></td>
					<td>Выключить моторы по заданным портам.</td>
				</tr>
				<tr>
					<td>Сбросить показания энкодера</td>
					<td><center><img src="pics/trik/clearEncoder.png" alt="Сбросить показания энкодера"></center></td>
					<td>Сбросить показания количества оборотов моторов по указанным портам.</td>
				</tr>
				<tr>
					<td>Угловой сервомотор</td>
					<td><center><img src="pics/trik/angularServo.png" alt="Угловой сервомотор"></center></td>
					<td>Установить валы угловых сервомоторов на указанных портах в указанное положение (в градусах, от -90 до 90).</td>
				</tr>
				<tr>
					<td>Сказать</td>
					<td><center><img src="pics/trik/say.png" alt="Сказать"></center></td>
					<td>Произнести с помощью динамика фразу, переданную в качестве аргумента блока.</td>
				</tr>
				<tr>
					<td>Светодиод</td>
					<td><center><img src="pics/trik/led.png" alt="Светодиод"></center></td>
					<td>Установить цвет светодиода на корпусе робота в указанный.</td>
				</tr>
				<tr>
					<td>Системный вызов</td>
					<td><center><img src="pics/trik/system.png" alt="Системный вызов"></center></td>
					<td>Блок имеет булевый параметр "Код". Если он установлен в "Истина", содержимое параметра "Команда" генерируется напрямую в текст программы при генерации этого блока. Если он установлен в "Ложь", генерируется вызов консольной команды операционной системы. Например, команда, представленная на рисунке, перезагружает робот.</td>
				</tr>
				<tr>
					<td>Включить видеокамеру</td>
					<td><center><img src="pics/trik/cameraOn.png" alt="Включить видеокамеру"></center></td>
					<td>Включить видеокамеру на роботе в одном из трёх режимов:
						<ol>
							<li><b>Сенсор линии</b> – детектирует цветную линию в центре кадра и в дальнейшем возвращает отклонение центра линии от центра кадра, как число в интервале от -100 (влево) до 100 (вправо).</li>
							<li><b>Сенсор объекта</b> – детектирует контрастный объект в центре кадра и в дальнейшем возвращает координаты его центра и диаметр в пикселах.</li>
							<li><b>Сенсор цвета</b> – возвращает доминирующий цвет в центре кадра в виде его координат в цветовой шкале RGB.</li>
						</ol>
					</td>
				</tr>
				<tr>
					<td>Детектировать по камере</td>
					<td><center><img src="pics/trik/cameraDetect.png" alt="Детектировать по камере"></center></td>
					<td>Фиксирует изображение в центре кадра и инициализирует им датчик линии или датчик объекта. Камера должна быть включена в соответствующем режиме блоком "Включить видеокамеру"</td>
				</tr>
				<tr>
					<td>Датчик линии в переменную</td>
					<td><center><img src="pics/trik/detectorToVariable.png" alt="Значение детектора в переменную"></center></td>
					<td>Помещает текущее показание датчика линии в указанную переменную. Камера должна быть включена в режиме датчика линии блоком "Включить видеокамеру" и проинициализирована блоком "Детектировать по камере"</td>
				</tr>
				<tr>
					<td>Послать сообщение</td>
					<td><center><img src="pics/trik/sendMessage.png" alt="Послать сообщение"></center></td>
					<td>Отправляет данное сообщение роботу с данным бортовым номером. Робот должен быть в той же сети, что и робот, отправляющий сообщение, и зарегистрирован как ведущий или ведомый с помощью меню "Настройки" -> "Сообщения" на роботе. Если роботов с данным бортовым номером в сети несколько, сообщение получат все они.</td>
				</tr>
				<tr>
					<td>Отправить сообщение в задачу</td>
					<td><center><img src="pics/trik/sendMessageThreads.png" alt="Отправить сообщение в задачу"></center></td>
					<td>Отправляет данное сообщение в параллельную задачу с заданным идентификатором (идентификатор должен
							быть указан при создании задачи в блоке "Параллельные задачи". В качестве сообщения может быть любое выражение.</td>
				</tr>
				<tr>
					<td>Записать в файл</td>
					<td><center><img src="pics/trik/writeToFile.png" alt="Записать в файл"></center></td>
					<td>Записывает значение данного выражения в заданный файл на роботе. Файл можно получить с робота, например,
							с помощью программы <a href="http://winscp.net/eng/docs/lang:ru">WinSCP</a> под Windows или scp под Linux.</td>
				</tr>
				<tr>
					<td>Удалить файл</td>
					<td><center><img src="pics/trik/removeFile.png" alt="Удалить файл"></center></td>
					<td>Удаляет заданный файл на роботе.</td>
				</tr>
				<tr>
					<td>Получить код кнопки</td>
					<td><center><img src="pics/trik/getButtonCode.png" alt="ПОлучить код кнопки"></center></td>
					<td>Сохраняет в указанную переменную код нажатой на роботе кнопки. Свойство "Ожидание" позволяет дождаться
					или не дожидаться, когда кнопка действительно будет нажата. Если нажатия кнопки блок не дожидается и кнопка
					не нажата, в переменную кладётся -1.</td>
				</tr>
			</table>

			<h4><a name="trik-waiting-blocks">Ожидания</a></h4>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название элемента</b></td>
					<td><b>Пиктограмма</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>Ждать датчик касания</td>
					<td><center><img src="pics/trik/waitTouch.png" alt="Ждать датчик касания"></center></td>
					<td>Ждать срабатывания датчика касания на указанном порту.</td>
				</tr>
				<tr>
					<td>Ждать свет</td>
					<td><center><img src="pics/trik/waitLight.png" alt="Ждать свет"></center></td>
					<td>Ждать, пока значение, возвращаемое сенсором света на указанном порту, не будет сравнимо с указанным в значении параметра "Проценты". Еще один парамер — номер порта, к которому подключен сенсор цвета. Также параметром указывается операция, которая будет использоваться для сравнения со значением параметра "Проценты". Так, при выполнении приведенного блока выполнение программы остановится до тех пор, пока значение, возвращаемое соответствующим сенсором света, не будет больше, чем 60 процентов.</td>
				</tr>
				<tr>
					<td>Ждать УЗ датчик расстояния</td>
					<td><center><img src="pics/trik/waitSonarDistance.png" alt="Ждать УЗ датчик расстояния"></center></td>
					<td>Ждать, пока расстояние, возвращаемое ультразвуковым сенсором расстояния, не будет сравнимо с указанным в значении параметра "Расстояние" (расстояние задается в сантиметрах, от 0 до 300). Еще один парамер — номер порта, к которому подключен датчик расстояния. Также параметром указывается операция, которая будет использоваться для сравнения с введенным расстоянием. Так, при выполнении приведенного блока выполнение программы остановится до тех пор, пока значение, возвращаемое сонаром, не будет больше, чем 40 см.</td>
				</tr>
				<tr>
					<td>Ждать ИК датчик расстояния</td>
					<td><center><img src="pics/trik/waitIrDistance.png" alt="Ждать ИК датчик расстояния"></center></td>
					<td>Ждать, пока расстояние, возвращаемое инфракрасным сенсором расстояния, не будет сравнимо с указанным в значении параметра "Расстояние". По умолчанию на портах A1 и A2 расстояние задается в сантиметрах (от 0 до 100), к остальным подключение не рекомендуется, так как чистое значение с датчика будет обработано с ожиданием другого подключенного датчика. Еще один парамер — номер порта, к которому подключен датчик расстояния. Также параметром указывается операция, которая будет использоваться для сравнения с введенным расстоянием. Так, при выполнении приведенного блока выполнение программы остановится до тех пор, пока значение, возвращаемое сонаром, не будет больше, чем 40 см.</td>
				</tr>
				<!-- <tr>
					<td>Ждать движения</td>
					<td><center><img src="pics/trik/waitMotion.png" alt="Ждать движения"></center></td>
					<td>Ждать, пока сенсор движения не зафиксирует движение.</td>
				</tr> -->
				<tr>
					<td>Ждать энкодер</td>
					<td><center><img src="pics/trik/waitEncoder.png" alt="Ждать энкодер"></center></td>
					<td>Ждать, пока показания счетчика количества оборотов на заданном порту не станут больше или меньше указанного в значении параметра "Предел оборотов".</td>
				</tr>
				<tr>
					<td>Ждать нажатия кнопки</td>
					<td><center><img src="pics/trik/waitForButton.png" alt="Ждать нажатия кнопки"></center></td>
					<td>Ждать, пока не будет нажата указанная кнопка на корпусе робота.</td>
				</tr>
				<tr>
					<td>Получить сообщение</td>
					<td><center><img src="pics/trik/waitMessage.png" alt="Ждать сообщения"></center></td>
					<td>Ждать получения сообщения через систему почтовых ящиков. Когда сообщение будет получено, оно будет
							помещено в указанную в параметре блока переменную. Свойство "Дождаться сообщения" позволяет указать,
							что делать, если очередь сообщений пуста: дождаться прихода нового сообщения или продолжить работу,
							положив в переменную пустую строку. Сообщение автоматически приводится к типу, соответствующему
							типу переменной-приёмника, то есть, например, можно послать число в виде строки и принять его как число.</td>
				</tr>
				<tr>
					<td>Ждать кнопки на пульте</td>
					<td><center><img src="pics/trik/waitGamepadButton.png" alt="Ждать кнопки на пульте"></center></td>
					<td>Ждать нажатия на "магическую кнопку" на Android-пульте, подключённом к роботу. Кнопки имеют номера с 1 по 5.</td>
				</tr>
				<tr>
					<td>Ждать нажатия на пульт</td>
					<td><center><img src="pics/trik/waitPadPress.png" alt="Ждать нажатия пульта"></center></td>
					<td>Ждать нажатия на одну из двух активных областей Android-пульта, подключённого к роботу.
							Координаты нажатия можно получить с помощью сенсорных переменных gamepadPad1 и gamepadPad2.</td>
				</tr>
				<tr>
					<td>Ждать &quot;руля&quot; на пульте</td>
					<td><center><img src="pics/trik/waitGamepadWheel.png" alt="Ждать &quot;руля&quot; на пульте"></center></td>
					<td>Ждать нужного наклона Android-пульта, подключённого к роботу. Наклон регистрируется только если на пульте
							включён режим &quot;руля&quot;, угол наклона кодируется числами от -100 (максимально влево)
							до 100 (максимально вправо). Также параметром указывается операция, которая будет использоваться
							для сравнения со значением параметра "Угол". Так, при выполнении приведенного блока выполнение
							программы остановится до тех пор, пока значение, возвращаемое &quot;рулём&quot;, не будет больше 0</td>
				</tr>
				<tr>
					<td>Ждать отключения пульта</td>
					<td><center><img src="pics/trik/waitGamepadDisconnect.png" alt="Ждать отключения пульта"></center></td>
					<td>Ждать, пока Android-пульт не отключится от робота. Если пульт не подключен, немедленно
							продолжает выполнение.</td>
				</tr>
				<tr>
					<td>Ждать подключения пульта</td>
					<td><center><img src="pics/trik/waitGamepadConnect.png" alt="Ждать подключения пульта"></center></td>
					<td>Ждать, пока к роботу не подключится Android-пульт. Если пульт уже подключен, немедленнно
							продолжает выполнение.</td>
				</tr>
				<tr>
					<td>Получить сообщение из другой задачи</td>
					<td><center><img src="pics/trik/waitMessageThreads.png" alt="Получить сообщение из другой задачи"></center></td>
					<td>Ждать получения сообщения из другой параллельной задачи. Когда сообщение будет получено, оно будет
							помещено в указанную в параметре блока переменную. Свойство "Дождаться сообщения" позволяет указать,
							что делать, если очередь сообщений пуста: дождаться прихода нового сообщения или продолжить работу,
							положив в переменную пустую строку. Сообщение автоматически приводится к типу, соответствующему
							типу переменной-приёмника, то есть, например, можно послать число в виде строки и принять его как число.</td>
				</tr>
			</table>

			<h4><a name="trik-drawing-blocks">Рисование на дисплее</a></h4>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название элемента</b></td>
					<td><b>Пиктограмма</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>Цвет кисти</td>
					<td><center><img src="pics/trik/setPainterColor.png" alt="Цвет кисти"></center></td>
					<td>Указать цвет, которым будут рисоваться простые графические фигуры на экране робота.</td>
				</tr>
				<tr>
					<td>Ширина кисти</td>
					<td><center><img src="pics/trik/setPainterWidth.png" alt="Ширина кисти"></center></td>
					<td>Указать ширину линии, которой будут рисоваться простые графические фигуры на экране робота.</td>
				</tr>
				<tr>
					<td>Нарисовать точку</td>
					<td><center><img src="pics/trik/drawPixel.png" alt="Нарисовать точку"></center></td>
					<td>Нарисовать на экране точку в указанных координатах.</td>
				</tr>
				<tr>
					<td>Нарисовать линию</td>
					<td><center><img src="pics/trik/drawLine.png" alt="Нарисовать линию"></center></td>
					<td>Нарисовать на экране отрезок. В качестве параметров блоку указываются концы отрезка.</td>
				</tr>
				<tr>
					<td>Нарисовать прямоугольник</td>
					<td><center><img src="pics/trik/drawRect.png" alt="Нарисовать прямоугольник"></center></td>
					<td>Нарисовать на экране прямоугольник. В качестве параметров указываются координаты левого верхнего угла, ширина и высота прямоугольника.</td>
				</tr>
				<tr>
					<td>Нарисовать эллипс</td>
					<td><center><img src="pics/trik/drawEllipse.png" alt="Нарисовать эллипс"></center></td>
					<td>Нарисовать на экране эллипс, вписанный в заданный прямоугольник.</td>
				</tr>
				<tr>
					<td>Нарисовать дугу</td>
					<td><center><img src="pics/trik/drawArc.png" alt="Нарисовать дугу"></center></td>
					<td>Нарисовать на экране дугу, задающуюся координатами прямоугольника, в который она будет вписана, и углами (в градусах) её начала и конца на окружности. Если начало и конец совпадают, будет нарисована полная окружность.</td>
				</tr>
				<tr>
					<td>Смайлик</td>
					<td><center><img src="pics/trik/smile.png" alt="Смайлик"></center></td>
					<td>Нарисовать на экране смайлик.</td>
				</tr>
				<tr>
					<td>Грустный смайлик</td>
					<td><center><img src="pics/trik/sadSmile.png" alt="Грустный смайлик"></center></td>
					<td>Нарисовать на экране грустный смайлик.</td>
				</tr>
				<tr>
					<td>Цвет фона</td>
					<td><center><img src="pics/trik/setBackground.png" alt="Цвет фона"></center></td>
					<td>Задаёт цвет фона экрана.</td>
				</tr>
				<tr>
					<td>Напечатать текст</td>
					<td><center><img src="pics/nxt/displayText.png" alt="Напечатать текст"></center></td>
					<td>Печатает заданную строку в заданном месте на экране робота. Значение свойства "Текст" по умолчанию трактуется как строка в чистом виде, оно так и будет выведено на экран. Чтобы система считала, что это выражение на текстовом языке (это может быть полезно, например, при отладке значения переменных), поставьте галочку "Вычислять" в редакторе свойств.</td>
				</tr>
				<tr>
					<td>Очистить экран</td>
					<td><center><img src="pics/nxt/clearScreen.png" alt="Очистить экран"></center></td>
					<td>Стереть всё, что нарисовано на экране.</td>
				</tr>
			</table>

			<p>
			Описание блоков, общих для всех конструкторов, можно посмотреть в разделе
			<a href="programming.html#blocks">Создание программ/Создание блоков</a>.
			</p>

			<h3><a name="sensor-variables">Сенсорные переменные</a></h3>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>accelerometer</td>
					<td>Массив из трёх элементов, содержащий показания акселерометра по оси X, Y и Z соответственно.</td>
				</tr>
				<tr>
					<td>colorSensorR, colorSensorG, colorSensorB</td>
					<td>Показания датчика цвета по видеокамере в центре кадра (интенсивность красного, зелёного и синего
							соответственно, от 0 до 255). Обновляются только когда датчик цвета включён и
							проинициализирован.</td>
				</tr>
				<tr>
					<td>encoder1, encoder2, encoder3, encoder4</td>
					<td>Показания экодера на порту E1, E2, E3 или E4 соответственно.</td>
				</tr>
				<tr>
					<td>buttonDown, buttonEnter, buttonEsc, buttonLeft, buttonRight, buttonUp</td>
					<td>Состояние кнопок на корпусе робота: кнопки "Вниз", "Ввод", "Отмена", "Влево", "Питание",
							"Вправо", "Вверх" соответственно. 0 соответствует ненажатой кнопке, 1 – нажатой.</td>
				</tr>
				<tr>
					<td>gamepadButton1, gamepadButton2, gamepadButton3, gamepadButton4, gamepadButton5</td>
					<td>Состояние кнопок на Android-пульте, кнопки с 1 по 5 соответственно. 0 соответствует ненажатой
							кнопке, 1 – нажатой.</td>
				</tr>
				<tr>
					<td>gamepadConnected</td>
					<td>Состояние подключения Android-пульта, 0 соответствует неподключенному пульту, 1 –
							подключенному.</td>
				</tr>
				<tr>
					<td>gamepadPad1, gamepadPad2</td>
					<td>Координаты нажатия активных областей на Android-пульте. Каждая переменная хранит в себе массив
							из двух элементов, соответствующих x- и y-координате точки нажатия. Координаты изменяются
							в границах от (-100, -100) до (100, 100), где (-100, -100) соответствует левому верхнему
							углу активной области. В случае, если область не нажата, в переменной находится значение
							(-101, -101).
					</td>
				</tr>
				<tr>
					<td>gamepadPad1Pressed, gamepadPad2Pressed</td>
					<td>Содержат 1, если соответствующая активная область на Android-пульте нажата и 0, если нет.
							Координаты нажатия можно узнать с помощью переменных gamepadPad1 и gamepadPad2.
					</td>
				</tr>
				<tr>
					<td>gamepadWheel</td>
					<td>Содержат текущий наклон Android-пульта, если он подключён и на нём включён &quot;руль&quot;.
							Наклон кодируется числами от -100 (крайнее левое положение) до 100 (крайнее правое
							положение). Если данных о положении &quot;руля&quot; нет, в переменной находится
							число -101.
					</td>
				</tr>
				<tr>
					<td>gyroscope</td>
					<td>Массив из трёх элементов, содержащий показания гироскопа по оси X, Y и Z соответственно.</td>
				</tr>
				<tr>
					<td>lineSensor</td>
					<td>Массив из трёх элементов:
						<ol>
							<li value="0">Координата линии датчика линии по видеокамере от -100 (крайнее левое положение линии в кадре)
									до 100 (крайнее правое положение). Обновляется только когда датчик линии включён и
									проинициализирован.
							</li>
							<li value="1">Вероятность перекрёстка, возвращаемая датчиком линии по видеокамере. Определяется как процент
									точек внутри горизонтальной полосы в центре кадра, распознанных как линия. В диапазоне от 0
									(таких точек нет) до 100 (все точки в горизонтальной полосе распознаны как линия).
									Обновляется только когда датчик линии включён и проинициализирован.
							</li>
							<li value="2">Относительный размер линии, то есть количество точек в кадре, определённых как линия, от 0
									(линии в кадре нет) до 100 (весь кадр распознан как линия). Обновляется только когда датчик
									линии включён и проинициализирован.
							</li>
						</ol>
					</td>
				</tr>
				<tr>
					<td>objectSensorX, objectSensorY, objectSensorSize</td>
					<td>Показания датчика объекта по видеокамере: координаты X, Y распознанного объекта (относительно
							центра кадра, от -100 до 100) и размер объекта (от 0 до 100, 100 – объект занимает весь
							кадр). Обновляются только когда датчик объекта включён и проинициализирован.</td>
				</tr>
				<tr>
					<td>sensorA1, sensorA2, sensorA3, sensorA4, sensorA5, sensorA6, sensorD1, sensorD2, sensorF1</td>
					<td>Показания датчиков на портах A1, A2, A3, A4, A5, A6, D1, D2, F1 соответственно.</td>
				</tr>
			</table>

			<h3><a name="textual-programming">Текстовое программирование</a></h3>
			<h4><a name="textual-programming-qts">Qt Script</a></h4>

			<p>
			Qt Script – интерпретируемый объектно-ориентированный язык с динамической типизацией, реализация стандарта ECMAScript (как и JavaScript, так что Qt Script можно рассматривать как диалект JavaScript). Подробное описание языка на русском можно найти, например, здесь: <a href="http://javascript.ru/ecma">http://javascript.ru/ecma</a>. При программировании на контроллере ТРИК используется библиотека, обеспечивающая взаимодействие скрипта с аппаратным обеспечением и некоторые расширения ECMAScript, описанные ниже.
			</p>

			<p>
			Пример простой программы на Qt Script:
			</p>

			<pre>
brick.smile();
script.wait(2000);</pre>

			<p>
			Здесь мы видим объект <b>brick</b>, у которого вызывается метод <b>smile</b> (нарисовать смайлик на экране) и
			объект <b>script</b>, у которого вызывается метод <b>wait</b> – ждать указанное количество миллисекунд.
			<b>brick</b> – объект, обеспечивающий взаимодействие скрипта с аппаратным обеспечением контроллера,
			<b>script</b> же отвечает за взаимодействие с операционной системой и управление исполнением скрипта.
			<b>brick</b> также предоставляет доступ к другим объектам, отвечающим за конкретные устройства, например,
			обращение к мотору на порту M1 выглядит так:
			</p>

			<pre>brick.motor(M1).setPower(100);</pre>

			<p>
			Пример более сложной программы, движение по линии с двумя сенсорами света:
			</p>

			<pre>var k = 1.3;
var power = 50;

var left = brick.sensor("A1").read();
var right = brick.sensor("A2").read();
while (true) {
	var u = k * (brick.sensor(A1).read() - left - (brick.sensor(A2).read() - right));
	brick.motor("M3").setPower(power + u);
	brick.motor("M4").setPower(power - u);
	script.wait(30);
}</pre>

			<p>
			Здесь видны объявления переменных – тип для них не указывается, он соответствует значениям, помещаемым в переменную.
			</p>

			<p>
			Одно из расширений стандартного ECMAScript, реализованное в Qt Script – возможность подписываться на события. Делается это с помощью функции connect, вызываемой от объекта-события, как в примере ниже. Там с помощью анонимной функции (описываемой с помощью ключевого слова <b>function</b>) скрипт подписывается на событие <b>pad</b>, соответствующее нажатию на одну из активных областей Android-пульта. На пульте их всего две, на какую именно из них нажали передаётся в параметре padId сигнала. <b>x</b> и <b>y</b> – координаты точки нажатия. Функция будет вызываться каждый раз, когда пользователь Android-пульт будет присылать сообщение, что на него нажали.
			</p>

			<pre>
gamepad.pad.connect(
	function(padId, x, y) {
		if (padId == 1) {
			brick.motor("E1").setPower(y);
			brick.motor("E2").setPower(-x);
		}

		if (padId == 2) {
			brick.motor("M1").setPower(y + x);
			brick.motor("M2").setPower(y - x);
		}
	}
)</pre>

			<p>
			Подобный стиль программирования называется реактивным (система реагирует на события) и пока не поддержан при
			генерации по диаграмме из TRIKStudio. То есть генерируемый код никогда не содержит вызовов <b>connect</b>,
			реактивные программы можно писать только вручную. Для того, чтобы программа не завершилась сразу же, а
			осталась работать и ожидать событий, используется метод <b>run</b> объекта <b>script</b>. Для выхода из
			режима ожидания и завершения работы событийно-ориентированного скрипта используется метод <b>stop</b>
			объекта <b>script</b>. Пример полной событийно-ориентированной программы, которая ждёт нажатия на кнопку
			"Ввод" и выходит, приведён ниже.
			</p>

			<pre>
brick.keys().buttonPressed.connect(
	function(code, value) {
		if (code == KeysEnum.Enter && value == 1) {
			print("'Enter' pressed, exiting");
			script.quit();
		}
	}
);

script.run();</pre>

			<p>
			Доступ к функциональности среды выполнения предоставляется с помощью предопределённых объектов:
			<ul>
				<li><a href="#textual-programming-qts-brick">brick</a></li>
				<li><a href="#textual-programming-qts-script">script</a></li>
				<li><a href="#textual-programming-qts-mailbox">mailbox</a></li>
				<li><a href="#textual-programming-qts-gamepad">gamepad</a></li>
				<li><a href="#textual-programming-qts-Threading">Threading</a></li>
			</ul>
			</p>

			<p>
			Список доступных методов и событий по классам и объектам приведён в таблице ниже.
			</p>

			<h5><a name="textual-programming-qts-brick">Объект "brick"</a></h5>

			<p>
			Представляет контроллер, предоставляет доступ к устройствам робота, таким как моторы и датчики.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>playSound</td>
					<td>brick.playSound('media/sound.mp3');</td>
					<td>Проиграть звуковой файл. Принимает в качестве параметра имя файла, который должен быть предварительно загружен на робот (с путём, абсолютным или относительно папки trik на роботе).</td>
				</tr>
				<tr>
					<td>say</td>
					<td>brick.say('Привет, я ТРИК');</td>
					<td>Произнести переданную как параметр строку (на русском или английском языке).</td>
				</tr>
				<tr>
					<td>stop</td>
					<td>brick.stop();</td>
					<td>Останавливает все моторы и активные датчики (такие как датчик линии или датчик объекта), убирает нарисованное на дисплее.</td>
				</tr>
				<tr>
					<td>motor</td>
					<td>brick.motor("M1");</td>
					<td>Возвращает мотор (класс <a href="#textual-programming-qts-motor">Motor</a>, силовой или сервомотор) на указанном порту.</td>
				</tr>
				<tr>
					<td>sensor</td>
					<td>brick.sensor("A1");</td>
					<td>Возвращает сенсор (класс <a href="#textual-programming-qts-sensor">Sensor</a>) на указанном порту.</td>
				</tr>
				<tr>
					<td>accelerometer</td>
					<td>brick.accelerometer();</td>
					<td>Возвращает акселерометр (класс <a href="#textual-programming-qts-sensor3d">Sensor3d</a>).</td>
				</tr>
				<tr>
					<td>gyroscope</td>
					<td>brick.gyroscope();</td>
					<td>Возвращает гироскоп (класс <a href="#textual-programming-qts-sensor3d">Sensor3d</a>).</td>
				</tr>
				<tr>
					<td>lineSensor</td>
					<td>brick.lineSensor();</td>
					<td>Возвращает датчик линии по видеокамере (класс <a href="#textual-programming-qts-lineSensor">LineSensor</a>).</td>
				</tr>
				<tr>
					<td>colorSensor</td>
					<td>brick.colorSensor();</td>
					<td>Возвращает датчик цвета по видеокамере (класс <a href="#textual-programming-qts-colorSensor">ColorSensor</a>).</td>
				</tr>
				<tr>
					<td>objectSensor</td>
					<td>brick.objectSensor();</td>
					<td>Возвращает датчик объекта по видеокамере (класс <a href="#textual-programming-qts-objectSensor">ObjectSensor</a>).</td>
				</tr>
				<tr>
					<td>encoder</td>
					<td>brick.encoder('B1');</td>
					<td>Возвращает энкодер на указанном порту (класс <a href="#textual-programming-qts-encoder">Encoder</a>).</td>
				</tr>
				<tr>
					<td>battery</td>
					<td>brick.battery();</td>
					<td>Возвращает объект, предоставляющий доступ к батарее (класс <a href="#textual-programming-qts-battery">Battery</a>).</td>
				</tr>
				<tr>
					<td>keys</td>
					<td>brick.keys();</td>
					<td>Возвращает объект, предоставляющий доступ к кнопкам на корпусе робота (класс <a href="#textual-programming-qts-keys">Keys</a>).</td>
				</tr>
				<tr>
					<td>display</td>
					<td>brick.display();</td>
					<td>Возвращает объект, предоставляющий доступ к дисплею робота (класс <a href="#textual-programming-qts-display">Display</a>).</td>
				</tr>
				<tr>
					<td>led</td>
					<td>brick.led();</td>
					<td>Возвращает объект, предоставляющий доступ к светодиоду на корпусе робота (класс <a href="#textual-programming-qts-led">Led</a>).</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-script">Объект "script"</a></h5>

			<p>
			Представляет методы управления выполнением скрипта и доступ к функциям операционной системы.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>timer</td>
					<td>script.timer(100);</td>
					<td>Создаёт и возвращает таймер (класс QTimer), посылающий сигнал timeout каждые n миллисекунд, где n передаётся в качестве параметра.</td>
				</tr>
				<tr>
					<td>wait</td>
					<td>script.wait(1000);</td>
					<td>Приостанавливает выполнение скрипта на переданное количество миллисекунд.</td>
				</tr>
				<tr>
					<td>time</td>
					<td>script.time();</td>
					<td>Возвращает временной штамп (число: количество миллисекунд, прошедших с начала 1 января 1970 года по Гринвичу).</td>
				</tr>
				<tr>
					<td>random</td>
					<td>var a = script.random(0, 10);</td>
					<td>Возвращает случайное число в диапазоне от первого до второго своего параметра.</td>
				</tr>
				<tr>
					<td>run</td>
					<td>script.run();</td>
					<td>Устанавливает флаг событийно-ориентированной программы. По окончанию работы скрипт не выгружается из памяти, а продолжает ждать наступления событий до тех пор, пока какой-либо из обработчиков не вызовет script.quit()</td>
				</tr>
				<tr>
					<td>quit</td>
					<td>script.quit();</td>
					<td>Устанавливает флаг окончания работы для событийно-ориентированной программы. Как только будет завершён текущий обработчик события, исполнение скрипта закончится.</td>
				</tr>
				<tr>
					<td>system</td>
					<td>script.system("reboot");</td>
					<td>Выполняет переданную в качестве параметра команду консоли операционной системы.</td>
				</tr>
				<tr>
					<td>writeToFile</td>
					<td>script.writeToFile('output.txt', 'Hello, world');</td>
					<td>Записывает значение второго параметра в файл, указанный в качестве первого параметра.</td>
				</tr>
				<tr>
					<td>readAll</td>
					<td>var lines = script.readAll('input.txt');</td>
					<td>Считывает всё содержимое указанного файла в массив строк.</td>
				</tr>
				<tr>
					<td>removeFile</td>
					<td>script.removeFile('file.txt');</td>
					<td>Удаляет указанный файл.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-mailbox">Объект "mailbox"</a></h5>

			<p>
			Реализует связь между роботами в сети посредством механизма почтовых ящиков.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>connect</td>
					<td>mailbox.connect("192.168.0.20", 8889);</td>
					<td>Подключается к роботу с заданным IP-адресом по заданному порту, сообщает ему свой бортовой номер
					и регистрируется в сети "почтовых ящиков".</td>
				</tr>
				<tr>
					<td>connect</td>
					<td>mailbox.connect("192.168.0.20");</td>
					<td>Подключается к роботу с заданным IP-адресом и портом по умолчанию, сообщает ему свой бортовой
					номер и регистрируется в сети "почтовых ящиков".</td>
				</tr>
				<tr>
					<td>send</td>
					<td>mailbox.send(1, "Hello");</td>
					<td>Посылает роботу с указанным бортовым номером указанное сообщение.</td>
				</tr>
				<tr>
					<td>send</td>
					<td>mailbox.send("Hello");</td>
					<td>Посылает указанное сообщение всем зарегистрированным роботам в сети.</td>
				</tr>
				<tr>
					<td>hasMessages</td>
					<td>mailbox.hasMessages();</td>
					<td>Возвращает true, если роботу пришло новое сообщение.</td>
				</tr>
				<tr>
					<td>receive</td>
					<td>var message = mailbox.receive();</td>
					<td>Получает новое сообщение или блокирует исполнение скрипта до тех пор, пока сообщение не придёт.</td>
				</tr>
				<tr>
					<td>myHullNumber</td>
					<td>var x = mailbox.myHullNumber();</td>
					<td>Возвращает бортовой номер робота.</td>
				</tr>
				<tr>
					<td>newMessage</td>
					<td>mailbox.newMessage.connect(function(sender, message) { print(message); });</td>
					<td>Посылается, когда робот получает новое сообщение. Первый параметр – бортовой номер отправителя,
					второй – само сообщение.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-gamepad">Объект "gamepad"</a></h5>

			<p>
			Служит для работы с Android-пультом управления, <a href="https://play.google.com/store/apps/details?id=com.trik.gamepad">https://play.google.com/store/apps/details?id=com.trik.gamepad</a>.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>reset</td>
					<td>gamepad.reset();</td>
					<td>Сбрасывает запомненные события от Android-пульта.</td>
				</tr>
				<tr>
					<td>buttonWasPressed</td>
					<td>gamepad.buttonWasPressed(1);</td>
					<td>Возвращает true, если на пульте была нажата кнопка с указанным номером. Сбрасывает запомненное
					нажатие для этой кнопки. Кнопки нумеруются от 1 до 5.</td>
				</tr>
				<tr>
					<td>isPadPressed</td>
					<td>gamepad.isPadPressed(1);</td>
					<td>Возвращает, нажата ли в данный момент область управления на пульте. Области управления имеют номера 0 и 1.</td>
				</tr>
				<tr>
					<td>padX</td>
					<td>gamepad.padX(1);</td>
					<td>Если указанная область управления на пульте нажата, возвращает текущую x-координату нажатия.</td>
				</tr>
				<tr>
					<td>padY</td>
					<td>gamepad.padY(1);</td>
					<td>Если указанная область управления на пульте нажата, возвращает текущую y-координату нажатия.</td>
				</tr>
				<tr>
					<td>wheel</td>
					<td>gamepad.wheel();</td>
					<td>Если на пульте включён "руль" (события от акселерометра Android-устройства), возвращает текущий
							наклон Android-пульта. Наклон кодируется числом от -100 до 100, -100
							соответствует крайнему левому положению "руля", 100 – крайнему правому.</td>
				</tr>
				<tr>
					<td>padUp</td>
					<td>gamepad.padUp.connect( function(padId, x, y) { brick.stop(); });</td>
					<td>Посылается, когда пользователь оторвал палец от области управления с указанным номером. В
					качестве параметров имеет номер области управления и координаты последнего известного положения
					пальца на ней.</td>
				</tr>
				<tr>
					<td>wheelEvent</td>
					<td>gamepad.wheelEvent.connect( function(percent) { brick.motor("E1").setPower(percent); });</td>
					<td>Посылается, когда на пульте включён "руль" (события от акселерометра Android-устройства) и
					пользователь повернул Android-устройство. В качестве параметра передаётся число от -100 до 100, -100
					соответствует крайнему левому положению "руля", 100 – крайнему правому.</td>
				</tr>
				<tr>
					<td>pad</td>
					<td>gamepad.pad.connect(function(padId, x, y) { print(padId + ":" + x + "," + y); });</td>
					<td>Посылается, когда пользователь нажал на область управления на пульте или переместил палец по
					ней. В качестве параметров передаётся номер области управления и координаты нажатия (числа от -100
					до 100, координата -100, -100 соответствует левому верхнему углу области управления).</td>
				</tr>
				<tr>
					<td>button</td>
					<td>gamepad.button.connect(function(button, pressed) { if (button == 1) brick.stop(); });</td>
					<td>Посылается, когда пользователь нажал на одну из пяти кнопок внизу пульта. Первый параметр –
					номер кнопки (от 1 до 5), второй – 1, если кнопка нажата, 0 – если кнопка отпущена.</td>
				</tr>
				<tr>
					<td>disconnect</td>
					<td>gamepad.button.disconnect(function() { brick.stop(); });</td>
					<td>Посылается при отключении пульта.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-threading">Объект "Threading"</a></h5>

			<p>
			Предоставляет управление параллельными потоками.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>startThread</td>
					<td>Threading.startThread("New thread id", "Function name");</td>
					<td>Запускает переданную в качестве параметра функцию в отдельном потоке. Обратите внимание, что
					при этом создаётся новая копия для всех глобальных переменных, так что если в одном потоке значение
					переменной меняется, в другом потоке оно остаётся старым.</td>
				</tr>
				<tr>
					<td>killThread</td>
					<td>Threading.killThread("Thread id");</td>
					<td>Заканчивает исполнение потока с заданным Thread id.</td>
				</tr>
				<tr>
					<td>joinThread</td>
					<td>Threading.joinThread("Thread id");</td>
					<td>Ожидает завершения всех потока с заданным Thread id.</td>
				</tr>
				<tr>
					<td>sendMessage</td>
					<td>Threading.sendMessage("Thread id", "New message");</td>
					<td>Посылает сообщение потоку с заданным Thread id.</td>
				</tr>
				<tr>
					<td>receiveMessage</td>
					<td>Threading.receiveMessage(wait);</td>
					<td>Запрашивает принятое сообщение, если wait равен true, то ожидает пока не придет сообщение.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-battery">Класс "Battery"</a></h5>

			<p>
			Предоставляет доступ к информации о батарее или блоке питания.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>readVoltage</td>
					<td>brick.battery().readVoltage();</td>
					<td>Возвращает текущий вольтаж батареи (или блока питания) в вольтах.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-colorSensor">Класс "ColorSensor"</a></h5>

			<p>
			Датчик цвета по видеокамере.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>init</td>
					<td>brick.colorSensor().init(true);</td>
					<td>Включает видеокамеру и инициализирует её в режиме датчика цвета. Булевый параметр определяет, выводить ли на экран изображение с камеры (true – выводить).</td>
				</tr>
				<tr>
					<td>read</td>
					<td>brick.colorSensor().read(2, 2);</td>
					<td>Возвращает массив с координатами доминирующего цвета в цветовой шкале RGB в указанном участке кадра. Кадр делится на квадраты сеткой, по умолчанию 3 на 3, размерность сетки можно задать в config.xml на роботе. Квадраты индексируются с 1, то есть (1, 1) – это левый верхний край кадра, (2, 2) – его центр. Возвращаемое значение – массив из трёх элементов от 0 до 255, индексирующийся с 0. Нулевой элемент содержит интенсивность красного (0 – совсем нет, 255 – очень много), первый – интенсивность зелёного, второй – интенсивность синего. Например, (0, 0, 0) – чёрный, (255, 255, 255) – белый, (255, 0, 0) – красный.</td>
				</tr>
				<tr>
					<td>stop</td>
					<td>brick.colorSensor().stop();</td>
					<td>Выключает видеокамеру и прекращает работу датчика.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-lineSensor">Класс "LineSensor"</a></h5>

			<p>
			Датчик линии по видеокамере.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>init</td>
					<td>brick.lineSensor().init(true);</td>
					<td>Включает видеокамеру и инициализирует её в режиме датчика линии. Булевый параметр определяет, выводить ли на экран изображение с камеры (true – выводить).</td>
				</tr>
				<tr>
					<td>detect</td>
					<td>brick.lineSensor().detect();</td>
					<td>Определяет доминирующий цвет в вертикальной полосе в центре кадра и запоминает его как цвет линии. После этого read() начинает возвращать данные для этой линии.</td>
				</tr>
				<tr>
					<td>read</td>
					<td>brick.lineSensor().read();</td>
					<td>Возвращает массив, в ячейках которого находятся следующие данные:
					<ul>
						<li>в нулевой ячейке координата по оси x центра линии относительно центра кадра (от -100 до 100, -100 – центр линии на краю кадра слева);</li>
						<li>в первой ячейке – вероятность перекрёстка (число от 0 до 100, показывающее сколько точек цвета линии находится в горизонтальной полосе в центре кадра);</li>
						<li>во второй ячейке – относительный размер линии, число от 0 до 100. 100 – линия занимает почти весь кадр, 0 – линии нет на кадре.</li>
					</ul>
					</td>
				</tr>
				<tr>
					<td>stop</td>
					<td>brick.lineSensor().stop();</td>
					<td>Выключает видеокамеру и прекращает работу датчика.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-objectSensor">Класс "ObjectSensor"</a></h5>

			<p>
			Датчик объекта по видеокамере. Захватывает контрастный объект в центре кадра и возвращает его координаты и размер в кадре .
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>init</td>
					<td>brick.objectSensor().init(true);</td>
					<td>Включает видеокамеру и инициализирует её в режиме датчика объекта. Булевый параметр определяет, выводить ли на экран изображение с камеры (true – выводить).</td>
				</tr>
				<tr>
					<td>detect</td>
					<td>brick.objectSensor().detect();</td>
					<td>Определяет доминирующий цвет в центре кадра и запоминает его как цвет объекта. После этого read() начинает возвращать данные для объекта.</td>
				</tr>
				<tr>
					<td>read</td>
					<td>brick.objectSensor().read();</td>
					<td>Возвращает массив, в ячейках которого находятся следующие данные:
					<ul>
						<li>в нулевой ячейке координата по оси x центра объекта относительно центра кадра (от -100 до 100, -100 – центр объекта на краю кадра слева);</li>
						<li>в первой ячейке – координата по оси y центра объекта относительно центра кадра (от -100 до 100, -100 – центр объекта на краю кадра сверху);</li>
						<li>во второй ячейке – относительный размер объекта, число от 0 до 100. 100 – объекта занимает почти весь кадр, 0 – объекта нет на кадре.</li>
					</ul>
					</td>
				</tr>
				<tr>
					<td>stop</td>
					<td>brick.objectSensor().stop();</td>
					<td>Выключает видеокамеру и прекращает работу датчика.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-sensor">Класс "Sensor"</a></h5>

			<p>
			Представляет сенсор (аналоговый или цифровой), подключающийся к портам A1, ..., A6, D1, D2, F1.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>read</td>
					<td>brick.sensor("A1").read();</td>
					<td>Возвращает текущее показание сенсора (цифрового или аналогового), подключённого к данному порту. Возвращается приведённое значение, зависящее от конфигурации порта, которая описывается в файле config.xml в папке trik на роботе. Например, ИК-датчик расстояния возвращает значение в сантиметрах.</td>
				</tr>
				<tr>
					<td>readRawData</td>
					<td>brick.sensor("A1").readRawData();</td>
					<td>Возвращает текущее "сырое" показание сенсора (цифрового или аналогового), подключённого к данному порту. Диапазон значений зависит от конкретного сенсора и не учитывает конфигурацию робота (возвращаются физические показания сенсора, например, задержка принятого ультразвукового сигнала).</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-sensor3d">Класс "Sensor3d"</a></h5>

			<p>
			Представляет сенсор, возвращающий в качестве значения массив из трёх чисел (гироскоп или акселерометр).
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>read</td>
					<td>brick.gyroscope().read();</td>
					<td>Возвращает текущее показание сенсора в виде массива из трёх элементов, соответствующих показаниям сенсора по каждой из осей.</td>
				</tr>
				<tr>
					<td>newData</td>
					<td>brick.gyroscope().newData.connect(function (x) { print(x[0]); });</td>
					<td>Сигнал, посылаемый сенсором, когда у него готовы новые данные. В качестве параметра передаётся массив из трёх элементов, соответствующих показаниям сенсора по каждой из осей.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-display">Класс "Display"</a></h5>

			<p>
			Предоставляет доступ к дисплею робота.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>showImage</td>
					<td>brick.display().showImage('media/trik_smile_sad.png');</td>
					<td>Вывести на экран изображение, предварительно загруженное на робот. Параметр – имя файла с изображением (в форматах BMP, GIF, JPG, JPEG, PNG, PBM, PGM, PPM, TIFF, XBM, XPM), путь указывается либо абсолютным, либо относительно папки trik.</td>
				</tr>
				<tr>
					<td>addLabel</td>
					<td>brick.display().addLabel('Привет, мир!', 1, 1);</td>
					<td>Вывести на экран переданный в качестве параметра текст в указанные координаты. Если в указанных координатах уже был текст, он будет заменён новым.</td>
				</tr>
				<tr>
					<td>removeLabels</td>
					<td>brick.display().removeLabels();</td>
					<td>Удаляет с экрана весь текст, добавленный на него вызовами метода addLabel().</td>
				</tr>
				<tr>
					<td>setPainterColor</td>
					<td>brick.display().setPainterColor("red");</td>
					<td>Устанавливает цвет кисти, которой рисуются графические примитивы. Возможные цвета таковы: white, red, darkRed, green, darkGreen, blue, darkBlue, cyan, darkCyan, magenta, darkMagenta, yellow, darkYellow, gray, darkGray, lightGray, black.</td>
				</tr>
				<tr>
					<td>setPainterWidth</td>
					<td>brick.display().setPainterWidth(5);</td>
					<td>Устанавливает толщину кисти, которой рисуются графические примитивы, в пикселах.</td>
				</tr>
				<tr>
					<td>drawLine</td>
					<td>brick.display().drawLine(0, 0, 10, 10);</td>
					<td>Рисует линию с началом и концом в заданных координатах.</td>
				</tr>
				<tr>
					<td>drawPoint</td>
					<td>brick.display().drawPoint(10, 10);</td>
					<td>Рисует точку в заданных координатах.</td>
				</tr>
				<tr>
					<td>drawRect</td>
					<td>brick.display().drawRect(0, 0, 10, 10);</td>
					<td>Рисует прямоугольник с левым верхним углом в указанных координатах и имеющий заданную ширину и высоту.</td>
				</tr>
				<tr>
					<td>drawEllipse</td>
					<td>brick.display().drawEllipse(0, 0, 10, 10);</td>
					<td>Рисует эллипс, вписанный в прямоугольник с левым верхним углом в указанных координатах и имеющий заданную ширину и высоту.</td>
				</tr>

				<tr>
					<td>drawArc</td>
					<td>brick.display().drawArc(0, 0, 10, 10, 20, 50);</td>
					<td>Рисует дугу эллипса, вписанного в прямоугольник с левым верхним углом в указанных координатах и имеющий заданную ширину и высоту. Последние два параметра – начальный и конечный угол, ограничивающие дугу.</td>
				</tr>
				<tr>
					<td>setBackground</td>
					<td>brick.display().setBackground("red");</td>
					<td>Устанавливает фон экрана в указанный цвет. Возможные цвета таковы: white, red, darkRed, green, darkGreen, blue, darkBlue, cyan, darkCyan, magenta, darkMagenta, yellow, darkYellow, gray, darkGray, lightGray, black.</td>
				</tr>
				<tr>
					<td>hide</td>
					<td>brick.display().hide();</td>
					<td>Закрывает и очищает окно для рисования.</td>
				</tr>
				<tr>
					<td>clear</td>
					<td>brick.display().clear();</td>
					<td>Очищает окно для рисования.</td>
				</tr>
				<tr>
					<td>redraw</td>
					<td>brick.display().redraw();</td>
					<td>Перерисовывает окно для рисования. Изменения в окне произойдут только после вызова этого метода.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-encoder">Класс "Encoder"</a></h5>

			<p>
			Представляет энкодеры силовых моторов, подключающиеся к портам B1, B2, B3, B4.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>read</td>
					<td>brick.encoder("B1").read();</td>
					<td>Возвращает текущее показание энкодера в градусах на заданном порту.</td>
				</tr>
				<tr>
					<td>readRawData</td>
					<td>brick.encoder("B1").readRawData();</td>
					<td>Возвращает текущее показание энкодера в "тиках" на заданном порту.</td>
				</tr>
				<tr>
					<td>reset</td>
					<td>brick.encoder("B1").reset();</td>
					<td>Сбрасывает в 0 текущее показание энкодера.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-keys">Класс "Keys"</a></h5>

			<p>
			Служит для работы с кнопками на пульте робота.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>reset</td>
					<td>brick.keys().reset();</td>
					<td>Сбрасывает запомненные нажатия кнопок.</td>
				</tr>
				<tr>
					<td>wasPressed</td>
					<td>brick.keys().wasPressed(KeysEnum.Up);</td>
					<td>Возвращает, была ли нажата кнопка с указанным кодом, сбрасывает запомненные нажатия для этой кнопки. Возможные варианты: KeysEnum.Left (код 105), KeysEnum.Up (код 103), KeysEnum.Down (код 108), KeysEnum.Enter (код 28), KeysEnum.Right (код 106), KeysEnum.Power (код 116), KeysEnum.Esc (код 1).</td>
				</tr>
				<tr>
					<td>isPressed</td>
					<td>brick.keys().isPressed(KeysEnum.Up);</td>
					<td>Возвращает true, если кнопка с указанным кодом нажата в данный момент.</td>
				</tr>
				<tr>
					<td>buttonPressed</td>
					<td>brick.keys().buttonPressed.connect(function(code, value) { if (code == KeysEnum.Up) brick.stop(); });</td>
					<td>Посылается, когда кнопка с указанным кодом нажата или отпущена. Первый параметр – код кнопки, второй – 1, если кнопка нажата, 0, если отпущена.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-led">Класс "Led"</a></h5>

			<p>
			Предоставляет управление светодиодом на корпусе робота.
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>red</td>
					<td>brick.led().red();</td>
					<td>Включает светодиод в режим "красный".</td>
				</tr>
				<tr>
					<td>green</td>
					<td>brick.led().green();</td>
					<td>Включает светодиод в режим "зелёный".</td>
				</tr>
				<tr>
					<td>orange</td>
					<td>brick.led().orange();</td>
					<td>Включает светодиод в режим "оранжевый".</td>
				</tr>
				<tr>
					<td>off</td>
					<td>brick.led().off();</td>
					<td>Выключает светодиод.</td>
				</tr>
			</table>

			<h5><a name="textual-programming-qts-motor">Класс "Motor"</a></h5>

			<p>
			Предоставляет управление мотором робота (силовым или сервомотором).
			</p>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>setPower</td>
					<td>brick.motor().setPower(100);</td>
					<td>Включает мотор с указанной мощностью. Мощность задаётся в диапазоне от -100 ("полный назад") до 100 ("полный вперёд"). 0 соответствует "force break", то есть мотор останавливается, при этом он заблокирован и остаётся под напряжением.</td>
				</tr>
				<tr>
					<td>power</td>
					<td>var x = brick.motor().power();</td>
					<td>Возвращает текущую мощность мотора (от -100 до 100).</td>
				</tr>
				<tr>
					<td>powerOff</td>
					<td>brick.motor().powerOff();</td>
					<td>Выключает мотор.</td>
				</tr>
			</table>

			<h4><a name="textual-programming-fsharp">F#</a></h4>

			<p>
			При программировании ТРИК на языке F# в качестве библиотеки поддержки времени выполнения используется библиотека
			TRIK-Sharp (<a href="https://github.com/kashmervil/trik-sharp">https://github.com/kashmervil/trik-sharp</a>),
			её описание и набор примеров доступны в Github-репозитории проекта. Познакомиться с языком F# и функциональным
			программированием вообще можно, например, с помощью книги Д. Сошникова "Программирование на F#"
			(<a href="http://www.ozon.ru/context/detail/id/6151130/">http://www.ozon.ru/context/detail/id/6151130/</a>).
			Обратите внимание, что для компиляции программ потребуется компилятор F# (устанавливаемый вместе со средой
			Microsoft Visual Studio версий не ниже 2010, отдельно его можно скачать отсюда:
			<a href="http://www.microsoft.com/en-us/download/details.aspx?id=44011">http://www.microsoft.com/en-us/download/details.aspx?id=44011</a>),
			а исполнения программ на роботе должен быть установлен пакет mono, который не устанавливается по умолчанию.
			</p>

			<h4><a name="textual-programming-pascal">Pascal</a></h4>

			<p>
			В качестве языка текстового программирования для ТРИК также может использоваться язык Паскаль (точнее, его
			диалект PascalABC.NET). Для этого должен быть установлен плагин поддержки Паскаля в TRIK Studio и компилятор
			PascalABC.NET, который можно скачать по ссылке
			<a href="http://pascalabc.net/ssyilki-dlya-skachivaniya">http://pascalabc.net/ssyilki-dlya-skachivaniya</a>.
			Достаточно консольного компилятора и необходимых компонент (PABCNETC.ZIP), если на компьютере установлен
			.NET Framework версии не ниже 4.5.1 или Mono. Путь до установленного компилятора (pabcnetc.exe) надо указать
			в настройках на вкладке "Роботы". При этом в этом же окне должна быть выставлена модель ТРИК версии 2015 года.
			</p>

			<p>
			В качестве библиотеки поддержки времени выполнения для программ на Паскале, как и в случае с F#, тоже используется
			библиотека TRIK-Sharp (<a href="https://github.com/kashmervil/trik-sharp">https://github.com/kashmervil/trik-sharp</a>),
			а в качестве среды выполнения – виртуальная машина mono, установленная на роботе (поэтому программы, как и в случае с
			F#, могут запускаться несколько секунд, это вполне нормально).
			</p>

			<p>
			Множество полезной информации о Паскале и его диалекте PascalABC.NET можно получить на сайте авторов этого
			компилятора, <a href="http://pascalabc.net/">http://pascalabc.net/</a>.
			</p>

			<h3><a name="run-programs">Запуск программ</a></h3>

			<p>
			Для ТРИК существует несколько вариантов выполнения программ:
			<ul>
				<li>пошаговая интерпретация диаграммы с посылкой команд в робота по Wi-Fi, или моделированием поведения робота с помощью двумерной модели</li>
				<li>загрузка и дальнейшее автономное исполнение программы на роботе без связи с компьютером.</li>
			</ul>
			</p>

			<h4><a name="run-programs-wifi">Интерпретация по Wi-Fi</a></h4>

			<p>
			Чтобы запустить программу на выполнение, необходимо подключиться к роботу (как описано в разделе <a href="#connection">Подключение робота</a>) и нажать кнопку "Выполнить" панели "Интерпретатор" или меню "Инструменты":
			</p>

			<center><img src="pics/trik/execute-toolbar.png" alt="Запуск программы"></center>

			<p>
			После этого интерпретатор ищет блок "Начало", с которого и начинается выполнение программы. Если такой блок на диаграмме не найден, будет выдано сообщение об ошибке. Для каждого функционального блока должна существовать ровно одна исходящая связь, по которой выполнение программы перейдет к следующему блоку. В противном случае будет выдано сообщение об ошибке.
			</p>

			<p>
			Для того, чтобы остановить выполнение программы, нужно нажать кнопку "Прервать выполнение" панели "Интерпретатор" или меню "Инструменты"
			</p>

			<h4><a name="run-programs-uploading">Загрузка программы на робот</a></h3>

			<p>
			Для загрузки и немедленного запуска программы в режиме Qt Script достаточно подключиться к Wi-Fi-сети с роботом,
			указать его IP-адрес в окне настроек или на панели справа (подробнее см. в разделе <a href="#connection">Подключение
			робота</a>) и нажать на кнопку "Загрузить и выполнить программу" (или выбрать соответствующий пункт меню):
			<p>

			<center><img src="pics/trik/upload-and-run-qts.png" alt="Загрузить и выполнить программу"></center>

			<p>
			Остановить исполняющуюся программу можно нажатием кнопки "Питание" на корпусе робота или кнопкой "Остановить робота"
			слева от кнопки "Загрузить и выполнить программу".
			</p>

			<p>
			Справа от кнопки "Загрузить и выполнить программу" находятся кнопки
			<ul>
				<li><b>Загрузить программу</b> – загружает программу на робот, но не исполняет её. Программа может быть исполнена
						из меню "Файлы" на роботе.</li>
				<li><b>Генерировать код на Qt Script</b> – не загружать программу на робот, а просто получить и открыть её
						представление на языке Qt Script. Программа может быть отредактирована (см. раздел <a href="#textual-programming-qts">
						Текстовое программирование – Qt Script</a>) и загружена на робот нажатием кнопок "Загрузить программу"
						или "Загрузить и выполнить программу" при открытой текстовой вкладке.</li>
			</ul>
			</p>

			<center><img src="pics/trik/upload-program-options.png" alt="Панель загрузки программ" ></center>

			<p>
			Для работы в режиме генерации в F# требуется сначала указать компилятор F# в окне настроек на вкладке "Роботы":
			</p>

			<center><img src="pics/trik/fsharp-compiler-setup.png" alt="Путь до компилятора F#" width="800"></center>

			<p>
			Затем можно пользоваться кнопками на панели F#, функциональность которых аналогична кнопкам на панели Qt Script. Обратите внимание, что программы на F# могут стартовать довольно долго, порядка 8-10 секунд.
			</p>

			<p>
			<b>Не все диаграммы, работающие в режиме интерпретации, могут быть сгенерированы в код на текстовых языках. Связано это с тем, что современные текстовые языки не позволяют явно управлять потоком исполнения, и программа должна быть представима в виде последовательно исполняемых операторов, подпрограмм, условий и циклов, быть может, вложенных друг в друга. Визуальные языки дают большую свободу, поэтому не всегда хорошо отображаются на текстовые. Если в окне сообщений об ошибках при попытке генерации появляется сообщение "ОШИБКА: Данная диаграмма не может быть сгенерирована в структурированный код", следует попытаться реструктуризовать и упростить программу, чтобы упростить задачу генератору.</b>
			</p>

		</div>
		<!-- end #content -->
		<div style="clear: both;">&nbsp;</div>
	</div>
	<!-- end #page -->
</div>
<script type="text/javascript" src="footer.html.js"></script>
</body>
</html>
